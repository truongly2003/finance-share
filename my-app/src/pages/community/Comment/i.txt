public CommentResponse createComment(CommentRequest commentRequest) {
        if (commentRequest.getPostId() == null || !postRepository.existsById(commentRequest.getPostId())) {
            throw new IllegalArgumentException("Invalid or non-existent postId: " + commentRequest.getPostId());
        }
        Comment comment = commentMapper.toComment(commentRequest);
        comment.setCreatedAt(LocalDateTime.now());
        comment.setUpdatedAt(LocalDateTime.now());
        Comment savedComment = commentRepository.save(comment);

        CommentResponse commentResponse = commentMapper.toCommentResponse(savedComment);
        commentResponse.setUserName(getUsername(comment.getUserId()));

        Post post = postRepository.findById(commentRequest.getPostId())
                .orElseThrow(() -> new RuntimeException("Post not found"));
        post.setCommentCount((int) commentRepository.countByPostId(commentRequest.getPostId()));
        post.setUpdatedAt(LocalDateTime.now());
        postRepository.save(post);

        LocalDateTime commentTime = savedComment.getCreatedAt();
//      send kafka to notification-service
//        kiểm tra comment có phải reply không
        Comment parentComment = null;
        if (commentRequest.getParentCommentId() != null) {
            parentComment = commentRepository.findById(commentRequest.getParentCommentId())
                    .orElseThrow(() -> new RuntimeException("Parent comment not found"));
        }
        if (parentComment == null) {
            //        id của chủ bài viết khác với người comment
            if (!post.getUserId().equals(commentRequest.getUserId())) {
                String actorName = getUsername(commentRequest.getUserId());

                List<Comment> allComments = commentRepository.findByPostIdOrderByCreatedAtAsc(commentRequest.getPostId());
                Set<String> distinctPreviousUsers = new LinkedHashSet<>();
                for (Comment c : allComments) {
//              Bỏ người đang comment hiện tại   và và Bỏ chủ bài viết (vì họ là người nhận thông báo).
                  if(!c.getUserId().equals(commentRequest.getUserId()) && !c.getUserId().equals(post.getUserId())) {
                      distinctPreviousUsers.add(c.getUserId());
                  }
                }
                String message;
                int previousCount = distinctPreviousUsers.size();
                if (previousCount == 0) {
                    message = "commented on your post";
                } else if (previousCount == 1) {
                    message = "and other person commented on your post";
                } else {
                    message = String.format("and %d other person comment on your post", previousCount);
                }

                NotificationEventDto notificationEventDto = new NotificationEventDto(
                        post.getUserId(), commentRequest.getUserId(), actorName, "post", message, "/community/post/detail-post/" + post.getId()
                );
                kafkaTemplate.send("notification_events", notificationEventDto);
            }

        } else {
            if (!parentComment.getUserId().equals(commentRequest.getUserId())) {
                String actorName = getUsername(commentRequest.getUserId());

                List<Comment> allComments=commentRepository.findByPostIdOrderByCreatedAtAsc(commentRequest.getPostId());
                Set<String> distinctPreviousUsers = new LinkedHashSet<>();
                for(Comment c : allComments) {
                    if(!c.getUserId().equals(commentRequest.getUserId()) && !c.getUserId().equals(post.getUserId())) {
                        distinctPreviousUsers.add(c.getUserId());
                    }
                }
                String message;
                int previousCount = distinctPreviousUsers.size();
                if (previousCount == 0) {
                    message="replied on your comment";
                }else if (previousCount == 1) {
                    message="and other person replied on your comment";
                }else {
                    message = String.format("and %d other person replied on your comment", previousCount);
                }
                // send kafka
                NotificationEventDto notificationEventDto = new NotificationEventDto(
                        parentComment.getUserId(), commentRequest.getUserId(), actorName, "reply",
                        "đã trả lời bình luận của bạn", "/community/post/detail-post/" + post.getId()
                );
                kafkaTemplate.send("notification_events", notificationEventDto);
            }
        }


        return commentResponse;
    }




method 2

private void sendNotification(Post post, CommentRequest request, Comment parentComment, boolean isReply) {
    String actorName = getUsername(request.getUserId());
    List<Comment> allComments = commentRepository.findByPostIdOrderByCreatedAtAsc(request.getPostId());
    Set<String> distinctPreviousUsers = allComments.stream()
            .filter(c -> !c.getUserId().equals(request.getUserId()) && !c.getUserId().equals(post.getUserId()))
            .map(Comment::getUserId)
            .collect(Collectors.toCollection(LinkedHashSet::new));

    int previousCount = distinctPreviousUsers.size();
    String message = isReply
            ? (previousCount == 0 ? "replied on your comment"
                : String.format("and %d other people replied on your comment", previousCount))
            : (previousCount == 0 ? "commented on your post"
                : String.format("and %d other people commented on your post", previousCount));

    String receiverId = isReply ? parentComment.getUserId() : post.getUserId();

    NotificationEventDto event = new NotificationEventDto(
            receiverId,
            request.getUserId(),
            actorName,
            isReply ? "reply" : "post",
            message,
            "/community/post/detail-post/" + post.getId()
    );
    kafkaTemplate.send("notification_events", event);
}



ví dụ
bài viết A : A đăng
B bình luận : thông báo cho A rằng B đã bình luận
C bình luận : thông báo cho A rằng C và 1 người nữa đã bình luận 

A bình luận chính bài của mình 

B sẽ trả lời bình luận của A : thông báo cho A là B đã trả lời bình luận   // logic này đang sai 